
pragma solidity ^0.6.0;

import "./ERC20byNoor.sol";
import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol";
//import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol";
import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/GSN/Context.sol";


contract buyable is ERC20Basic
{
   address payable public owner;
   address buyer;
    ERC20Basic public token;
    uint256 public tokenPrice;
    uint256 public tokensSold=0;
    uint256 public amountobuy;
    event sell(address owner , uint256 amount);
    
constructor(ERC20Basic _token) public payable
{
    token=_token;
    owner=msg.sender;
    tokenPrice=100;
}



function isContract(address account) internal view returns (bool) {
        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts
        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned
        // for accounts without code, i.e. `keccak256('')`
        bytes32 codehash;
        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
        // solhint-disable-next-line no-inline-assembly
        assembly { codehash := extcodehash(account) }
        return (codehash != accountHash && codehash != 0x0);
    }
modifier isEOA()
{
    if(isContract(buyer) == false)
    _;
}

function buyTokens(uint _numberOfTokens) isEOA payable external
{
    
    uint256 amount = _numberOfTokens*tokenPrice;
    transfer(msg.sender,amount);
    tokensSold += _numberOfTokens;
    emit sell(msg.sender, _numberOfTokens);
}


   
}
