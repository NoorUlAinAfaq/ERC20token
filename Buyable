pragma solidity ^0.6.0;

import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol";
import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol";
import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/GSN/Context.sol";

contract buyable is ERC20
{
   address payable public owner;
    address payable buyer;
    ERC20 public _token;
    uint256 public tokenPrice;
    uint256 public tokensSold=0;
    uint256 public amountobuy;
    event sell(address buyer, uint256 amount);
    
constructor(ERC20 token) ERC20("Buyable Token", "BUYT") public payable
{
    //token=_token;
    _token = token;
    owner=msg.sender;
    tokenPrice=100;
}



function isContract(address account) internal view returns (bool) {
        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts
        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned
        // for accounts without code, i.e. `keccak256('')`
        bytes32 codehash;
        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
        // solhint-disable-next-line no-inline-assembly
        assembly { codehash := extcodehash(account) }
        return (codehash != accountHash && codehash != 0x0);
    }



function buyTokens(uint _numberOfTokens) payable external
{
    
    uint256 amount = _numberOfTokens*tokenPrice;
    _token.transfer(_msgSender(),amount);
    tokensSold += _numberOfTokens;
    emit sell(buyer, _numberOfTokens);
}

   
}
